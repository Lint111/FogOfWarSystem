// VisibilityCheck.compute
// Stage 2: Check all seeables against all groups
// [FIX] One thread group per seeable - 64 threads cooperate to evaluate units

#pragma kernel ComputeAllGroupsVisibility
#pragma kernel VisibilityCheck_PerGroup    // [PARALLEL] Single-group kernel for parallel dispatch

#include "Common.hlsl"
#include "SDFEvaluation.hlsl"

// =============================================================================
// SHARED MEMORY - All threads in group cooperate on ONE seeable
// =============================================================================

groupshared UnitSDFContribution g_SharedUnits[SHARED_UNIT_BATCH_SIZE];

// Reduction scratch space for finding minimum SDF and nearest unit
groupshared float g_SharedSDF[64];
groupshared float g_SharedDist[64];
groupshared int g_SharedNearestUnit[64];

// =============================================================================
// BINDINGS
// =============================================================================

StructuredBuffer<VisionGroupData> _GroupData;
StructuredBuffer<UnitSDFContribution> _UnitContributions;
StructuredBuffer<SeeableEntityData> _SeeableEntities;
StructuredBuffer<uint> _GroupIslandMasks;

// Player fog volume (for efficient player group lookup)
Texture3D<float> _PlayerFogVolume;
SamplerState sampler_PlayerFogVolume;

RWStructuredBuffer<VisibilityCandidate> _Candidates;
RWStructuredBuffer<int> _CandidateCounts;       // [PARALLEL] Per-group candidate counters (8 ints)
StructuredBuffer<int> _CandidateOffsets;         // [PARALLEL] Per-group candidate buffer offsets

uint _GroupCount;
uint _SeeableCount;
uint _PlayerGroupId;
uint _MaxCandidatesPerGroup;                     // [PARALLEL] Max candidates per group
uint _ActiveGroupMask;  // Bitmask of groups with active units (for early rejection)
uint _TargetGroupId;    // [PARALLEL] Which group to process (for VisibilityCheck_PerGroup kernel)
float3 _VolumeWorldMin;
float3 _VolumeWorldMax;

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

float3 WorldToVolumeUVW(float3 worldPos)
{
    return saturate((worldPos - _VolumeWorldMin) / (_VolumeWorldMax - _VolumeWorldMin));
}

// =============================================================================
// COOPERATIVE UNIT EVALUATION
// All 64 threads work together to evaluate units for ONE seeable
// =============================================================================

void EvaluateGroupCooperative(
    uint threadIdx,
    float3 targetPos,
    VisionGroupData viewer,
    out float bestSDF,
    out int nearestUnit,
    out float nearestDist)
{
    // Initialize per-thread accumulators
    float localBestSDF = 1e10;
    float localNearestDist = 1e10;
    int localNearestUnit = -1;

    uint totalUnits = (uint)viewer.unitCount;
    uint unitStart = (uint)viewer.unitStartIndex;

    // Process units in batches that fit in shared memory
    for (uint batchStart = 0; batchStart < totalUnits; batchStart += SHARED_UNIT_BATCH_SIZE)
    {
        uint batchSize = min(SHARED_UNIT_BATCH_SIZE, totalUnits - batchStart);

        // Cooperative load: 64 threads load up to 128 units (2 per thread)
        uint unitsPerThread = (batchSize + 63) / 64;
        for (uint i = 0; i < unitsPerThread; i++)
        {
            uint localIdx = threadIdx + i * 64;
            if (localIdx < batchSize)
            {
                g_SharedUnits[localIdx] = _UnitContributions[unitStart + batchStart + localIdx];
            }
        }

        // ALL threads must reach this barrier
        GroupMemoryBarrierWithGroupSync();

        // Each thread evaluates a portion of the batch
        // Thread 0 evals units 0, 64, 128... Thread 1 evals 1, 65, 129...
        // This distributes work evenly
        for (uint j = threadIdx; j < batchSize; j += 64)
        {
            UnitSDFContribution unit = g_SharedUnits[j];

            float dist = length(targetPos - unit.position);

            // Distance cull
            if (dist > viewer.maxViewDistance + unit.primaryRadius)
                continue;

            float sdf = EvaluateUnitVision(targetPos, unit);

            if (sdf < localBestSDF)
                localBestSDF = sdf;

            if (dist < localNearestDist)
            {
                localNearestDist = dist;
                localNearestUnit = (int)(unitStart + batchStart + j);
            }
        }

        // Sync before next batch overwrites shared memory
        GroupMemoryBarrierWithGroupSync();
    }

    // Store local results in shared memory for reduction
    g_SharedSDF[threadIdx] = localBestSDF;
    g_SharedDist[threadIdx] = localNearestDist;
    g_SharedNearestUnit[threadIdx] = localNearestUnit;

    GroupMemoryBarrierWithGroupSync();

    // Parallel reduction to find global minimum SDF and nearest unit
    // 64 -> 32 -> 16 -> 8 -> 4 -> 2 -> 1
    for (uint stride = 32; stride > 0; stride >>= 1)
    {
        if (threadIdx < stride)
        {
            if (g_SharedSDF[threadIdx + stride] < g_SharedSDF[threadIdx])
            {
                g_SharedSDF[threadIdx] = g_SharedSDF[threadIdx + stride];
            }
            if (g_SharedDist[threadIdx + stride] < g_SharedDist[threadIdx])
            {
                g_SharedDist[threadIdx] = g_SharedDist[threadIdx + stride];
                g_SharedNearestUnit[threadIdx] = g_SharedNearestUnit[threadIdx + stride];
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // Thread 0 has the final results
    bestSDF = g_SharedSDF[0];
    nearestUnit = g_SharedNearestUnit[0];
    nearestDist = g_SharedDist[0];
}

// Find nearest unit cooperatively (for player group after fog volume check)
void FindNearestUnitCooperative(
    uint threadIdx,
    float3 targetPos,
    VisionGroupData viewer,
    out int nearestUnit,
    out float nearestDist)
{
    float localNearestDist = 1e10;
    int localNearestUnit = -1;

    uint totalUnits = (uint)viewer.unitCount;
    uint unitStart = (uint)viewer.unitStartIndex;

    for (uint batchStart = 0; batchStart < totalUnits; batchStart += SHARED_UNIT_BATCH_SIZE)
    {
        uint batchSize = min(SHARED_UNIT_BATCH_SIZE, totalUnits - batchStart);

        // Cooperative load
        uint unitsPerThread = (batchSize + 63) / 64;
        for (uint i = 0; i < unitsPerThread; i++)
        {
            uint localIdx = threadIdx + i * 64;
            if (localIdx < batchSize)
            {
                g_SharedUnits[localIdx] = _UnitContributions[unitStart + batchStart + localIdx];
            }
        }

        GroupMemoryBarrierWithGroupSync();

        // Distributed evaluation
        for (uint j = threadIdx; j < batchSize; j += 64)
        {
            float d = length(targetPos - g_SharedUnits[j].position);
            if (d < localNearestDist)
            {
                localNearestDist = d;
                localNearestUnit = (int)(unitStart + batchStart + j);
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }

    // Reduction
    g_SharedDist[threadIdx] = localNearestDist;
    g_SharedNearestUnit[threadIdx] = localNearestUnit;

    GroupMemoryBarrierWithGroupSync();

    for (uint stride = 32; stride > 0; stride >>= 1)
    {
        if (threadIdx < stride)
        {
            if (g_SharedDist[threadIdx + stride] < g_SharedDist[threadIdx])
            {
                g_SharedDist[threadIdx] = g_SharedDist[threadIdx + stride];
                g_SharedNearestUnit[threadIdx] = g_SharedNearestUnit[threadIdx + stride];
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }

    nearestUnit = g_SharedNearestUnit[0];
    nearestDist = g_SharedDist[0];
}

// =============================================================================
// MAIN KERNEL
// Dispatch: (seeableCount, 1, 1) - one thread GROUP per seeable
// =============================================================================

[numthreads(64, 1, 1)]
void ComputeAllGroupsVisibility(
    uint3 groupId : SV_GroupID,
    uint threadIdx : SV_GroupIndex)
{
    // All 64 threads in this group process the SAME seeable
    uint seeableIndex = groupId.x;

    if (seeableIndex >= _SeeableCount)
        return;

    SeeableEntityData seeable = _SeeableEntities[seeableIndex];

    float3 targetPos = seeable.position;
    float targetRadius = seeable.boundingRadius;
    uint ownerGroupId = GetSeeableOwnerGroupId(seeable);
    uint seeableByMask = GetSeeableMask(seeable);

    // EARLY REJECTION: XOR mask check - skip if no potential viewers
    // Compute which groups COULD see this seeable (active & allowed & not owner)
    uint potentialViewers = ComputePotentialViewers(_ActiveGroupMask, seeableByMask, ownerGroupId);
    if (potentialViewers == 0)
        return; // No possible viewers - skip entirely (before any sync, so safe)

    // Iterate over all groups - use shouldProcess flag instead of continue
    // This ensures ALL threads reach GroupMemoryBarrierWithGroupSync
    for (uint g = 0; g < _GroupCount; g++)
    {
        // Determine if this group should be processed (uniform across all threads)
        bool shouldProcess = true;

        // Skip if this group can't possibly see this seeable
        if ((potentialViewers & (1u << g)) == 0)
            shouldProcess = false;

        VisionGroupData viewer = _GroupData[g];

        if (shouldProcess)
        {
            uint viewerVisibilityMask = GetVisibilityMask(viewer);

            // Check if viewer can see target's group (bidirectional check)
            if ((viewerVisibilityMask & (1u << ownerGroupId)) == 0)
                shouldProcess = false;

            // Skip if viewer group has no units
            if (viewer.unitCount == 0)
                shouldProcess = false;

            // Quick bounds rejection (uniform across threads)
            float distToGroup = length(targetPos - viewer.groupCenter);
            if (distToGroup > viewer.maxViewDistance + viewer.groupBoundingRadius + targetRadius)
                shouldProcess = false;
        }

        float visibility = 0.0;
        int nearestUnit = -1;
        float nearestDist = 1e10;

        if (shouldProcess)
        {
            if (g == _PlayerGroupId)
            {
                // Player: sample precomputed fog volume
                float3 uvw = WorldToVolumeUVW(targetPos);
                visibility = _PlayerFogVolume.SampleLevel(sampler_PlayerFogVolume, uvw, 0);

                if (visibility > VISIBILITY_THRESHOLD)
                {
                    // All threads cooperate to find nearest unit
                    FindNearestUnitCooperative(threadIdx, targetPos, viewer, nearestUnit, nearestDist);
                }
            }
            else
            {
                // AI groups: cooperative SDF evaluation
                float bestSDF;
                EvaluateGroupCooperative(threadIdx, targetPos, viewer, bestSDF, nearestUnit, nearestDist);
                visibility = SDFToVisibility(bestSDF, targetRadius);
            }

            // Only thread 0 writes the candidate
            if (threadIdx == 0 && visibility > VISIBILITY_THRESHOLD && nearestUnit >= 0)
            {
                // [PARALLEL] Use per-group counter and offset
                int localIdx;
                InterlockedAdd(_CandidateCounts[g], 1, localIdx);

                if ((uint)localIdx < _MaxCandidatesPerGroup)
                {
                    // [PARALLEL] Global index = group offset + local index
                    int globalIdx = _CandidateOffsets[g] + localIdx;

                    VisibilityCandidate candidate;
                    candidate.entityId = seeable.entityId;
                    candidate.seeableIndex = (int)seeableIndex;
                    candidate.viewerGroupId = (int)g;
                    candidate.nearestUnitIndex = nearestUnit;
                    candidate.distance = nearestDist;
                    candidate.padding = float3(0, 0, 0);

                    _Candidates[globalIdx] = candidate;
                }
                else
                {
                    // Overflow - decrement counter
                    InterlockedAdd(_CandidateCounts[g], -1);
                }
            }
        }

        // ALL threads must sync before next group iteration - no divergence here
        GroupMemoryBarrierWithGroupSync();
    }
}

// =============================================================================
// [PARALLEL] SINGLE-GROUP KERNEL
// Processes only _TargetGroupId - no loop, no inter-group barriers
// Dispatch 8 of these in parallel for full parallelism
// =============================================================================

[numthreads(64, 1, 1)]
void VisibilityCheck_PerGroup(
    uint3 groupId : SV_GroupID,
    uint threadIdx : SV_GroupIndex)
{
    // All 64 threads in this group process the SAME seeable for _TargetGroupId
    uint seeableIndex = groupId.x;
    uint g = _TargetGroupId;

    if (seeableIndex >= _SeeableCount)
        return;

    // Early exit if this group is not active
    if ((_ActiveGroupMask & (1u << g)) == 0)
        return;

    SeeableEntityData seeable = _SeeableEntities[seeableIndex];

    float3 targetPos = seeable.position;
    float targetRadius = seeable.boundingRadius;
    uint ownerGroupId = GetSeeableOwnerGroupId(seeable);
    uint seeableByMask = GetSeeableMask(seeable);

    // Skip if this seeable is owned by target group (can't see yourself)
    if (ownerGroupId == g)
        return;

    // Skip if this group is not allowed to see this seeable
    if ((seeableByMask & (1u << g)) == 0)
        return;

    VisionGroupData viewer = _GroupData[g];

    // Skip if viewer group has no units
    if (viewer.unitCount == 0)
        return;

    // Check if viewer can see target's group (bidirectional check)
    uint viewerVisibilityMask = GetVisibilityMask(viewer);
    if ((viewerVisibilityMask & (1u << ownerGroupId)) == 0)
        return;

    // Quick bounds rejection
    float distToGroup = length(targetPos - viewer.groupCenter);
    if (distToGroup > viewer.maxViewDistance + viewer.groupBoundingRadius + targetRadius)
        return;

    float visibility = 0.0;
    int nearestUnit = -1;
    float nearestDist = 1e10;

    if (g == _PlayerGroupId)
    {
        // Player: sample precomputed fog volume
        float3 uvw = WorldToVolumeUVW(targetPos);
        visibility = _PlayerFogVolume.SampleLevel(sampler_PlayerFogVolume, uvw, 0);

        if (visibility > VISIBILITY_THRESHOLD)
        {
            // All threads cooperate to find nearest unit
            FindNearestUnitCooperative(threadIdx, targetPos, viewer, nearestUnit, nearestDist);
        }
    }
    else
    {
        // AI groups: cooperative SDF evaluation
        float bestSDF;
        EvaluateGroupCooperative(threadIdx, targetPos, viewer, bestSDF, nearestUnit, nearestDist);
        visibility = SDFToVisibility(bestSDF, targetRadius);
    }

    // Only thread 0 writes the candidate
    if (threadIdx == 0 && visibility > VISIBILITY_THRESHOLD && nearestUnit >= 0)
    {
        int localIdx;
        InterlockedAdd(_CandidateCounts[g], 1, localIdx);

        if ((uint)localIdx < _MaxCandidatesPerGroup)
        {
            int globalIdx = _CandidateOffsets[g] + localIdx;

            VisibilityCandidate candidate;
            candidate.entityId = seeable.entityId;
            candidate.seeableIndex = (int)seeableIndex;
            candidate.viewerGroupId = (int)g;
            candidate.nearestUnitIndex = nearestUnit;
            candidate.distance = nearestDist;
            candidate.padding = float3(0, 0, 0);

            _Candidates[globalIdx] = candidate;
        }
        else
        {
            InterlockedAdd(_CandidateCounts[g], -1);
        }
    }
}
