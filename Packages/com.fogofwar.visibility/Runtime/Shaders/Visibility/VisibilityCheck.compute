// VisibilityCheck.compute
// Stage 2: Check all seeables against all groups

#pragma kernel ComputeAllGroupsVisibility

#include "Common.hlsl"
#include "SDFEvaluation.hlsl"

// =============================================================================
// [M1 FIX] SHARED MEMORY DECLARATION
// =============================================================================

// Shared memory for cooperative unit loading
// Used when finding nearest unit in player group
groupshared UnitSDFContribution g_SharedUnits[SHARED_UNIT_BATCH_SIZE];

// =============================================================================
// BINDINGS
// =============================================================================

StructuredBuffer<VisionGroupData> _GroupData;
StructuredBuffer<UnitSDFContribution> _UnitContributions;
StructuredBuffer<SeeableEntityData> _SeeableEntities;
StructuredBuffer<uint> _GroupIslandMasks;

// Player fog volume (for efficient player group lookup)
Texture3D<float> _PlayerFogVolume;
SamplerState sampler_PlayerFogVolume;

RWStructuredBuffer<VisibilityCandidate> _Candidates;
RWStructuredBuffer<int> _CandidateCount;

uint _GroupCount;
uint _SeeableCount;
uint _PlayerGroupId;
uint _MaxCandidates;            // [C2 FIX] Max buffer size for bounds checking
float3 _VolumeWorldMin;
float3 _VolumeWorldMax;

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

float3 WorldToVolumeUVW(float3 worldPos)
{
    return saturate((worldPos - _VolumeWorldMin) / (_VolumeWorldMax - _VolumeWorldMin));
}

// =============================================================================
// MAIN KERNEL
// =============================================================================

// [M1 FIX] Helper: Find nearest unit using shared memory batching
// All threads in group cooperatively load units, then each thread searches
void FindNearestUnitShared(
    uint3 groupThreadId,
    float3 targetPos,
    VisionGroupData viewer,
    out int nearestUnit,
    out float nearestDist)
{
    nearestUnit = -1;
    nearestDist = 1e10;

    uint totalUnits = (uint)viewer.unitCount;
    uint unitStart = (uint)viewer.unitStartIndex;

    // Process units in batches that fit in shared memory
    for (uint batchStart = 0; batchStart < totalUnits; batchStart += SHARED_UNIT_BATCH_SIZE)
    {
        uint batchSize = min(SHARED_UNIT_BATCH_SIZE, totalUnits - batchStart);

        // Cooperative load: each thread loads some units
        // Thread group size is 64, batch size up to 128
        // Each thread loads up to 2 units
        uint unitsPerThread = (batchSize + 63) / 64;
        for (uint i = 0; i < unitsPerThread; i++)
        {
            uint localIdx = groupThreadId.x + i * 64;
            if (localIdx < batchSize)
            {
                g_SharedUnits[localIdx] = _UnitContributions[unitStart + batchStart + localIdx];
            }
        }

        // Ensure all threads have finished loading
        GroupMemoryBarrierWithGroupSync();

        // Each thread now searches this batch
        for (uint j = 0; j < batchSize; j++)
        {
            float d = length(targetPos - g_SharedUnits[j].position);
            if (d < nearestDist)
            {
                nearestDist = d;
                nearestUnit = (int)(unitStart + batchStart + j);
            }
        }

        // Sync before next batch overwrites shared memory
        GroupMemoryBarrierWithGroupSync();
    }
}

// [M1 FIX] Helper: Evaluate group SDF using shared memory batching
float EvaluateGroupVisionWithSharedMemory(
    uint3 groupThreadId,
    float3 targetPos,
    VisionGroupData viewer,
    out int nearestUnit,
    out float nearestDist)
{
    float bestSDF = 1e10;
    nearestUnit = -1;
    nearestDist = 1e10;

    uint totalUnits = (uint)viewer.unitCount;
    uint unitStart = (uint)viewer.unitStartIndex;

    // Process units in batches
    for (uint batchStart = 0; batchStart < totalUnits; batchStart += SHARED_UNIT_BATCH_SIZE)
    {
        uint batchSize = min(SHARED_UNIT_BATCH_SIZE, totalUnits - batchStart);

        // Cooperative load
        uint unitsPerThread = (batchSize + 63) / 64;
        for (uint i = 0; i < unitsPerThread; i++)
        {
            uint localIdx = groupThreadId.x + i * 64;
            if (localIdx < batchSize)
            {
                g_SharedUnits[localIdx] = _UnitContributions[unitStart + batchStart + localIdx];
            }
        }

        GroupMemoryBarrierWithGroupSync();

        // Evaluate this batch
        for (uint j = 0; j < batchSize; j++)
        {
            UnitSDFContribution unit = g_SharedUnits[j];

            float dist = length(targetPos - unit.position);
            if (dist > viewer.maxViewDistance + unit.primaryRadius)
                continue;

            float sdf = EvaluateUnitVision(targetPos, unit);

            if (sdf < bestSDF)
                bestSDF = sdf;

            if (dist < nearestDist)
            {
                nearestDist = dist;
                nearestUnit = (int)(unitStart + batchStart + j);
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }

    return bestSDF;
}

[numthreads(64, 1, 1)]
void ComputeAllGroupsVisibility(uint3 id : SV_DispatchThreadID, uint3 groupThreadId : SV_GroupThreadID)
{
    if (id.x >= _SeeableCount)
        return;

    // [C1 FIX] id.x IS the seeable index - we'll pass this directly
    uint seeableIndex = id.x;
    SeeableEntityData seeable = _SeeableEntities[seeableIndex];

    float3 targetPos = seeable.position;
    float targetRadius = seeable.boundingRadius;
    uint ownerGroupId = seeable.ownerGroupId & 0xFF;
    uint seeableByMask = seeable.seeableByMask & 0xFF;

    // Check against each group
    for (uint g = 0; g < _GroupCount; g++)
    {
        // Skip self-visibility
        if (g == ownerGroupId)
            continue;

        // Check permission mask
        if ((seeableByMask & (1u << g)) == 0)
            continue;

        VisionGroupData viewer = _GroupData[g];
        uint viewerVisibilityMask = viewer.visibilityMask & 0xFF;

        // Check if viewer can see target's group
        if ((viewerVisibilityMask & (1u << ownerGroupId)) == 0)
            continue;

        // Quick bounds rejection
        float distToGroup = length(targetPos - viewer.groupCenter);
        if (distToGroup > viewer.maxViewDistance + viewer.groupBoundingRadius + targetRadius)
            continue;

        float visibility = 0.0;
        int nearestUnit = -1;
        float nearestDist = 1e10;

        // Different evaluation path for player vs AI groups
        if (g == _PlayerGroupId)
        {
            // Player: sample precomputed fog volume
            float3 uvw = WorldToVolumeUVW(targetPos);
            visibility = _PlayerFogVolume.SampleLevel(sampler_PlayerFogVolume, uvw, 0);

            // [M1 FIX] Use shared memory for nearest unit search
            if (visibility > VISIBILITY_THRESHOLD)
            {
                FindNearestUnitShared(groupThreadId, targetPos, viewer, nearestUnit, nearestDist);
            }
        }
        else
        {
            // [M1 FIX] AI groups: Use shared memory optimized SDF evaluation
            float sdf = EvaluateGroupVisionWithSharedMemory(
                groupThreadId,
                targetPos,
                viewer,
                nearestUnit,
                nearestDist);

            visibility = SDFToVisibility(sdf, targetRadius);
        }

        // Passed visibility threshold - add to candidates
        if (visibility > VISIBILITY_THRESHOLD && nearestUnit >= 0)
        {
            int idx;
            InterlockedAdd(_CandidateCount[0], 1, idx);

            // [C2 FIX] Bounds check before writing
            if ((uint)idx >= _MaxCandidates)
            {
                // Overflow - decrement counter and skip
                InterlockedAdd(_CandidateCount[0], -1);
                return;
            }

            VisibilityCandidate candidate;
            candidate.entityId = seeable.entityId;
            candidate.seeableIndex = (int)seeableIndex;  // [C1 FIX] Pass index directly
            candidate.viewerGroupId = (int)g;
            candidate.nearestUnitIndex = nearestUnit;
            candidate.distance = nearestDist;
            candidate.padding = float3(0, 0, 0);

            _Candidates[idx] = candidate;
        }
    }
}
