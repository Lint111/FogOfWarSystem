// RayMarchConfirm.compute
// Stage 3: Ray march to confirm visibility (occlusion check)

#pragma kernel RayMarchConfirmation
#pragma kernel PrepareRayMarchDispatch

#include "Common.hlsl"
#include "IslandSampling.hlsl"

// =============================================================================
// BINDINGS
// =============================================================================

StructuredBuffer<VisionGroupData> _GroupData;
StructuredBuffer<UnitSDFContribution> _UnitContributions;
StructuredBuffer<SeeableEntityData> _SeeableEntities;
StructuredBuffer<VisibilityCandidate> _Candidates;
StructuredBuffer<int> _CandidateCount;
StructuredBuffer<uint> _GroupIslandMasks;

RWStructuredBuffer<VisibilityEntry> _VisibleEntities;
RWStructuredBuffer<int> _VisibleCounts;         // Per group counter
StructuredBuffer<int> _VisibleOffsets;          // Per group start offset

// Indirect dispatch args buffer (for PrepareRayMarchDispatch kernel)
RWStructuredBuffer<IndirectDispatchArgs> _IndirectArgs;

uint _SeeableCount;
uint _MaxVisiblePerGroup;

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

// [C1 FIX] REMOVED FindSeeableById - now using direct index from candidate

uint ComputeVisibilityLevel(float distance)
{
    // 0 = edge (far), 1 = partial (medium), 2 = full (close)
    if (distance < 5.0) return 2;
    if (distance < 15.0) return 1;
    return 0;
}

// =============================================================================
// MAIN KERNEL
// =============================================================================

[numthreads(64, 1, 1)]
void RayMarchConfirmation(uint3 id : SV_DispatchThreadID)
{
    int candidateCount = _CandidateCount[0];
    if (id.x >= (uint)candidateCount)
        return;

    VisibilityCandidate candidate = _Candidates[id.x];

    // Get viewer unit position
    UnitSDFContribution viewerUnit = _UnitContributions[candidate.nearestUnitIndex];
    float3 viewerPos = viewerUnit.position;

    // [C1 FIX] Use seeableIndex directly instead of linear search
    // OLD: SeeableEntityData target = FindSeeableById(candidate.entityId);
    SeeableEntityData target = _SeeableEntities[candidate.seeableIndex];

    // Validate the index points to correct entity (defensive check)
    if (target.entityId != candidate.entityId)
        return;

    float3 targetPos = target.position;

    // Compute which islands the ray passes through
    uint rayIslandMask = ComputeRayIslandMask(viewerPos, targetPos);

    // Also include group's known relevant islands
    rayIslandMask |= _GroupIslandMasks[candidate.viewerGroupId];

    // Ray march to confirm visibility
    bool isVisible = RayMarchThroughIslands(
        viewerPos,
        targetPos,
        rayIslandMask,
        target.boundingRadius);

    if (isVisible)
    {
        uint groupId = (uint)candidate.viewerGroupId;
        int offset = _VisibleOffsets[groupId];

        int localIdx;
        InterlockedAdd(_VisibleCounts[groupId], 1, localIdx);

        // [C2 FIX] Bounds check before writing
        if ((uint)localIdx >= _MaxVisiblePerGroup)
        {
            // Overflow - decrement and skip
            InterlockedAdd(_VisibleCounts[groupId], -1);
            return;
        }

        int globalIdx = offset + localIdx;

        VisibilityEntry entry;
        entry.entityId = candidate.entityId;
        entry.seenByUnitIndex = candidate.nearestUnitIndex;
        entry.distance = candidate.distance;
        entry.packed = ComputeVisibilityLevel(candidate.distance); // visibilityLevel in low byte

        _VisibleEntities[globalIdx] = entry;
    }
}

// =============================================================================
// INDIRECT DISPATCH PREPARATION
// =============================================================================

/// <summary>
/// Prepares indirect dispatch arguments for RayMarchConfirmation.
/// Run this kernel before DispatchIndirect to set thread group count
/// based on actual candidate count (avoids CPU readback).
/// </summary>
[numthreads(1, 1, 1)]
void PrepareRayMarchDispatch(uint3 id : SV_DispatchThreadID)
{
    uint candidateCount = (uint)max(0, _CandidateCount[0]);

    // Calculate thread groups needed (ceil divide by thread group size)
    uint threadGroups = (candidateCount + THREAD_GROUP_1D - 1) / THREAD_GROUP_1D;

    // Ensure at least 1 thread group (required by DispatchIndirect)
    threadGroups = max(1, threadGroups);

    _IndirectArgs[0].threadGroupCountX = threadGroups;
    _IndirectArgs[0].threadGroupCountY = 1;
    _IndirectArgs[0].threadGroupCountZ = 1;
    _IndirectArgs[0].padding = 0;
}
